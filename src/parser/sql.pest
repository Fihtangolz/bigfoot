WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

// sql statements
sql_statements = _{
    SOI ~  
    (sql_schema_statement
    | sql_data_statement
    | sql_transaction_statement
    | sql_control_statement
    | sql_connection_statement
    | sql_session_statement
    | sql_diagnostics_statement
    | sql_dynamic_statement)
    ~ EOI
}

//5.1 sql terminal character
sql_terminal_character = {
    sql_language_character
} 
sql_language_character = {
    simple_latin_letter 
    | digit 
    | sql_special_character 
}
simple_latin_letter = {
    simple_latin_upper_case_letter 
    | simple_latin_lower_case_letter
} 
simple_latin_upper_case_letter = {
    "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O"
    |"P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
}
simple_latin_lower_case_letter = {
    "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o"
    | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
}
digit = _{
    "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
}
sql_special_character = {
    space 
    | double_quote 
    | percent 
    | ampersand 
    | quote 
    | left_paren 
    | right_paren 
    | asterisk 
    | plus_sign 
    | comma 
    | minus_sign 
    | period 
    | solidus 
    | colon 
    | semicolon 
    | less_than_operator 
    | equals_operator 
    | greater_than_operator 
    | question_mark 
    | left_bracket 
    | right_bracket 
    | circumflex 
    | underscore 
    | vertical_bar 
    | left_brace 
    | right_brace 
    | dollar_sign 
    | apostrophe 
}
space = {" "} 
double_quote = {"\""}
percent = {"%"}
ampersand = {"&"}
quote = {"\'"}
left_paren = _{"("}
right_paren = _{")"}
asterisk = {"*"}
plus_sign = {"+"}
comma = {","}
minus_sign = {"-"}
period = {"."}
solidus = {"/"}
reverse_solidus = {"\\"}
colon = {":"}
semicolon = {";"}
less_than_operator = {"<"}
equals_operator = {"="}
greater_than_operator = {">"}
question_mark = {"?"}
left_bracket_or_trigraph = {
    left_bracket 
    | left_bracket_trigraph 
}
right_bracket_or_trigraph = {
    right_bracket 
    | right_bracket_trigraph 
}
left_bracket = {"["}
left_bracket_trigraph = {"??("}
right_bracket = {"]"}
right_bracket_trigraph = {"??)"}
circumflex = {"^"}
underscore = {"_"}
vertical_bar = {"|"}
left_brace = {"{"}
right_brace = {"}"}
dollar_sign = {"$"}
apostrophe = {"\'"}

//5.2 token and separator
// token = {
//     nondelimiter_token 
//     | delimiter_token 
// }
// nondelimiter_token = {
//     regular_identifier 
//     | key_word 
//     | unsigned_numeric_literal   
//     | large_object_length_token 
//     | unicode_delimited_identifier 
//     | sql_language_identifier
// }
regular_identifier = {
    identifier_body 
}
identifier_body = {
    identifier_part*
}
identifier_part = { 
    "TODO"
} 
large_object_length_token = {
    digit* ~ multiplier 
}
multiplier = {
    "K"
    | "M"
    | "G"
    | "T"
    | "P"
}
delimited_identifier = {
    double_quote ~ delimited_identifier_body ~ double_quote
} 
delimited_identifier_body = {
    delimited_identifier_part* 
}
delimited_identifier_part = { 
    "TODO" 
}
unicode_delimited_identifier = {
    "U" ~ ampersand ~ double_quote ~ unicode_delimiter_body ~ double_quote 
    ~ unicode_escape_specifier
} 
unicode_escape_specifier = {
    ("UESCAPE" ~ quote ~ quote)?
}
unicode_delimiter_body = {
    unicode_identifier_part*
}
unicode_identifier_part = {
    delimited_identifier_part 
    | unicode_escape_value 
}
unicode_escape_value = {
    unicode_4_digit_escape_value 
    | unicode_6_digit_escape_value 
    | unicode_character_escape_value
} 
unicode_4_digit_escape_value = {
    "unicode_escape_character" ~ hexit ~ hexit ~ hexit ~ hexit
} 
unicode_6_digit_escape_value = {
    "unicode_escape_character" ~ plus_sign 
    ~ hexit ~ hexit ~ hexit ~ hexit ~ hexit ~ hexit
} 
unicode_character_escape_value = {
    "unicode_escape_character" ~ "unicode_escape_character" 
}
delimiter_token = {
    character_string_literal 
    // | date_string 
    // | time_string 
    // | timestamp_string 
    // | interval_string 
    | delimited_identifier 
    | sql_special_character 
    // | not_equals_operator 
    // | greater_than_or_equals_operator 
    // | less_than_or_equals_operator 
    // | concatenation_operator 
    // | right_arrow 
    | left_bracket_trigraph 
    | right_bracket_trigraph 
    // | double_colon 
    // | double_period 
    // | named_argument_assignment_token 
    // | left_brace_minus 
    // | right_minus_brace 
}
key_word = {
    reserved_word 
    | non_reserved_word 
}
non_reserved_word = {
    "A"
}
reserved_word = {
    "ABS"
}
concatenation_operator = {
    "||"
}
right_arrow = {
    "->"
}
double_colon = {
    "::"
}
not_equals_operator = {
    "<<" | "<>" | ">>"
}
less_than_or_equals_operator = {
    "<="
}
greater_than_or_equals_operator = {
    ">="
}

//5.3 literal
literal = {
    // signed_numeric_literal 
    general_literal
} 
general_literal = {
    character_string_literal 
    // | national_character_string_literal 
    // | unicode_character_string_literal 
    // | binary_string_literal 
    // | datetime_literal 
    // | interval_literal 
    | boolean_literal
} 
character_string_literal = {
    (introducer ~ "character_set_specification")?
    ~ quote ~ character_representation* ~ quote 
    ~ ("separator" ~ quote ~ (character_representation)* ~ quote)*
}
introducer = {underscore} 
character_representation = {
    "nonquote_character" 
    | "quote_symbol" 
}
unsigned_literal = {
    unsigned_numeric_literal 
    | general_literal
} 
hexit = {
    digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f"
}
unsigned_numeric_literal = {
    exact_numeric_literal 
    | "approximate_numeric_literal" 
}
exact_numeric_literal = {
    "unsigned_integer" ~ (period ~ "unsigned_integer"?)?
    | period ~ "unsigned_integer" 
}
unsigned_integer = _{
    digit*
}
datetime_value = {"unsigned_integer"} 
boolean_literal = {
    "TRUE"
    | "FALSE"
    | "UNKNOWN"
}
sign = {
    plus_sign 
    | minus_sign 
}

//5.4 names and identifiers
identifier = {
    actual_identifier
}
actual_identifier = {
    // regular_identifier
    delimited_identifier
    | unicode_delimited_identifier
}
sql_language_identifier = {
    sql_language_identifier_start ~ sql_language_identifier_part*
}
sql_language_identifier_start = {
    simple_latin_letter
}
sql_language_identifier_part = {
    simple_latin_letter
    | digit
    | underscore
}
authorization_identifier = {
    role_name
    | user_identifier
}
table_name = {
    local_or_schema_qualified_name
}
domain_name = {
    schema_qualified_name
}
schema_name = {
    (catalog_name ~ period)? ~ unqualified_schema_name
}
unqualified_schema_name = {
    identifier
}
catalog_name = {
    identifier
}
schema_qualified_name = {
    (schema_name ~ period)? ~ qualified_identifier
}
local_or_schema_qualified_name = {
    (local_or_schema_qualifier ~ period)? ~ qualified_identifier
}
local_or_schema_qualifier = {
    schema_name
    | local_qualifier
}
qualified_identifier = {
    identifier
}
column_name = {
    identifier
}
correlation_name = {
    identifier
}
query_name = {
    identifier
}
sql_client_module_name = {
    identifier
}
procedure_name = {
    identifier
}
schema_qualified_routine_name = {
    schema_qualified_name
}
method_name = {
    identifier
}
specific_name = {
    schema_qualified_name
}
cursor_name = {
    local_qualified_name
}
local_qualified_name = {
    (local_qualifier ~ period)? ~ qualified_identifier
}
local_qualifier = {
    "MODULE"
}
host_parameter_name = {
    colon ~ identifier
}
sql_parameter_name = {
    identifier
}
constraint_name = {
    schema_qualified_name
}
external_routine_name = {
    identifier
    | character_string_literal
}
trigger_name = {
    schema_qualified_name
}
collation_name = {
    schema_qualified_name
}
character_set_name = {
    (schema_name ~ period)? ~ sql_language_identifier
}
transliteration_name = {
    schema_qualified_name
}
transcoding_name = {
    schema_qualified_name
}
schema_resolved_user_defined_type_name = {
    user_defined_type_name
}
user_defined_type_name = {
    (schema_name ~ period)? ~ qualified_identifier
}
attribute_name = {
    identifier
}
field_name = {
    identifier
}
savepoint_name = {
    identifier
}
sequence_generator_name = {
    schema_qualified_name
}
role_name = {
    identifier
}
user_identifier = {
    identifier
}
connection_name = {
    simple_value_specification
}
sql_server_name = {
    simple_value_specification
}
connection_user_name = {
    simple_value_specification
}
sql_statement_name = {
    statement_name 
    | extended_statement_name
}
statement_name = {
    identifier
}
extended_statement_name = {
    scope_option? ~ simple_value_specification
}
dynamic_cursor_name = {
    conventional_dynamic_cursor_name 
    | ptf_cursor_name 
}
conventional_dynamic_cursor_name = {
    cursor_name 
    | extended_cursor_name 
}
extended_cursor_name = {
    scope_option? ~ simple_value_specification
}
ptf_cursor_name = {
    "PTF" ~ simple_value_specification
} 
descriptor_name = {
    conventional_descriptor_name
    | ptf_descriptor_name
}
conventional_descriptor_name = {
    non_extended_descriptor_name 
    | extended_descriptor_name 
}
non_extended_descriptor_name = {
    identifier
}
extended_descriptor_name = {
    scope_option? ~ simple_value_specification
}
scope_option = {
    "GLOBAL"
    | "LOCAL"
}
ptf_descriptor_name = {
    "PTF" ~ simple_value_specification
} 
window_name = {
    identifier
}
row_pattern_variable_name = {
    correlation_name
}
measure_name = {
    identifier
}

//6.1 data type
data_type = {
    predefined_type
    | row_type
    | path_resolved_user_defined_type_name
    | reference_type
    | collection_type
}
predefined_type = {
    character_string_type ~ "CHARACTER" ~ "SET" ~  character_set_specification 
    ~ collate_clause?
    | national_character_string_type ~ collate_clause?
    | binary_string_type
    | numeric_type
    | boolean_type
    | datetime_type
    | interval_type
}
character_string_type = {
    "CHARACTER" ~ (left_paren ~ character_length ~ right_paren)*
    | "CHAR" ~ (left_paren ~ character_length ~ right_paren)*
    | "CHARACTER" ~ "VARYING" ~ left_paren ~ character_length ~ right_paren
    | "CHAR" ~ "VARYING" ~ left_paren ~ character_length ~ right_paren
    | "VARCHAR" ~ left_paren ~ character_length ~ right_paren
    | character_large_object_type
}
character_large_object_type = {
    "CHARACTER" ~ "LARGE" ~ "OBJECT" ~ (left_paren ~ character_large_object_length ~ right_paren)*
    | "CHAR" ~ "LARGE" ~ "OBJECT" ~ (left_paren ~ character_large_object_length ~ right_paren)*
    | "CLOB" ~  (left_paren ~ character_large_object_length ~ right_paren)*
}
binary_large_object_string_type = {
    "BINARY" ~ "LARGE" ~ "OBJECT" ~ (left_paren ~ large_object_length ~ right_paren)*
    | "BLOB" ~ (left_paren ~ large_object_length ~ right_paren)?
}
numeric_type = {
    exact_numeric_type
    | approximate_numeric_type
}
exact_numeric_type = {
    "NUMERIC" ~ (left_paren ~ precision ~ (comma ~ scale)? ~ right_paren)?
    | "DECIMAL" ~ (left_paren ~ precision ~ (comma ~ scale)? ~ right_paren)?
    | "DEC" ~ (left_paren ~ precision ~ (comma ~ scale)? ~ right_paren)*
    | "SMALLINT"
    | "INTEGER"
    | "INT"
    | "BIGINT"
}
approximate_numeric_type = {
    "FLOAT" ~ (left_paren ~ precision ~ right_paren)?
    | "REAL"
    | "DOUBLE" ~ "PRECISION"
}
national_character_string_type = {
    "NATIONAL" ~ "CHARACTER" ~ (left_paren ~ character_length ~ right_paren)?
    | "NATIONAL" ~ "CHAR" ~ (left_paren ~ character_length ~ right_paren)?
    | "NCHAR" ~ (left_paren ~ character_length ~ right_paren)*
    | "NATIONAL" ~ "CHARACTER" ~ "VARYING" ~ left_paren ~ character_length ~ right_paren
    | "NATIONAL" ~ "CHAR" ~ "VARYING" ~ left_paren ~ character_length ~ right_paren
    | "NCHAR" ~ "VARYING" ~ left_paren ~ character_length ~ right_paren
    | national_character_large_object_type
}
national_character_large_object_type = {
    "NATIONAL" ~ "CHARACTER" ~ "LARGE" ~ "OBJECT" ~ (left_paren ~ character_large_object_length ~ right_paren)?
    | "NCHAR" ~ "LARGE" ~ "OBJECT" ~ (left_paren ~ character_large_object_length ~ right_paren)?
    | "NCLOB" ~ (left_paren ~ character_large_object_length ~ right_paren)?
}
binary_string_type = {
    "BINARY" ~ (left_paren ~ length ~ right_paren)?
    | "BINARY" ~ "VARYING" ~ left_paren ~ length ~ right_paren
    | "VARBINARY" ~ left_paren ~ length ~ right_paren
    | binary_large_object_string_type
}
decimal_floating_point_type = {
    "DECFLOAT" ~ (left_paren ~ precision ~ right_paren)?
}
length = {
    unsigned_integer
}
character_length = {
    length ~ char_length_units?
}
large_object_length = {
    length ~ multiplier
    | large_object_length_token
}
character_large_object_length = {
    large_object_length ~ char_length_units?
}
char_length_units = {
    "CHARACTERS"
    | "OCTETS"
}
precision = {
    unsigned_integer
}
scale = {
    unsigned_integer
}
boolean_type = {
    "BOOLEAN"
}
datetime_type = {
    "DATE"
    | "TIME" ~ (left_paren ~ time_precision ~ right_paren)? ~ (with_or_without_time_zone)?
    | "TIMESTAMP" ~ (left_paren ~ timestamp_precision ~ right_paren)?
    ~ (with_or_without_time_zone)?
}
with_or_without_time_zone = {
    "WITH" ~ "TIME" ~ "ZONE"
    | "WITHOUT" ~ "TIME" ~ "ZONE"
}
time_precision = {
    time_fractional_seconds_precision
}
timestamp_precision = {
    time_fractional_seconds_precision
} 
time_fractional_seconds_precision = _{
    unsigned_integer 
}
interval_type = {
    "INTERVAL" ~ interval_qualifier
}
row_type = {
    "ROW" ~ row_type_body
}
row_type_body = {
    left_paren ~ field_definition ~ (comma ~ field_definition)* ~ right_paren
}
reference_type = {
    "REF" ~ left_paren ~ referenced_type ~ right_paren ~ scope_clause?
}
scope_clause = {
    "SCOPE" ~ table_name
}
referenced_type = {
    path_resolved_user_defined_type_name
}
path_resolved_user_defined_type_name = {
    user_defined_type_name
}
collection_type = {
    array_type
    | multiset_type
}
array_type = {
    data_type ~ "ARRAY"
    ~ left_bracket_or_trigraph ~ maximum_cardinality ~ right_bracket_or_trigraph   
}
maximum_cardinality = {
    unsigned_integer
}
multiset_type = {
    data_type ~ "MULTISET"
}

//6.2 field definition
field_definition = {
    field_name ~ data_type
} 

//6.3 value expression primary
value_expression_primary = {
    parenthesized_value_expression 
    | nonparenthesized_value_expression_primary
} 
parenthesized_value_expression = {
    left_paren ~ value_expression ~ right_paren
} 
nonparenthesized_value_expression_primary = {
    unsigned_value_specification 
    | column_reference 
    | set_function_specification 
    | window_function 
    | nested_window_function 
    | scalar_subquery 
    | case_expression 
    | cast_specification 
    | field_reference 
    | subtype_treatment 
    | method_invocation 
    | static_method_invocation 
    | new_specification 
    | attribute_or_method_reference 
    | reference_resolution 
    | collection_value_constructor 
    | array_element_reference 
    | multiset_element_reference 
    | next_value_expression 
    | routine_invocation 
    | row_pattern_navigation_operation 
    | json_value_function 
}
collection_value_constructor = {
    array_value_constructor 
    | multiset_value_constructor
}

//6.4 value specification and target specification
value_specification = {
    literal 
    | general_value_specification
} 
unsigned_value_specification = {
    unsigned_literal 
    | general_value_specification
} 
general_value_specification = {
    host_parameter_specification 
    // | sql_parameter_reference 
    | dynamic_parameter_specification 
    | embedded_variable_specification 
    | current_collation_specification 
    | "CURRENT_CATALOG"
    | "CURRENT_DEFAULT_TRANSFORM_GROUP"
    | "CURRENT_PATH"
    | "CURRENT_ROLE"
    | "CURRENT_SCHEMA"
    | "CURRENT_TRANSFORM_GROUP_FOR_TYPE"  
    | "CURRENT_USER"
    | "SESSION_USER"
    | "SYSTEM_USER"
    | "USER"
    | "VALUE"
}
simple_value_specification = {
    literal 
    | host_parameter_name 
    // | sql_parameter_reference 
    // | embedded_variable_name 
}
target_specification = {
    host_parameter_specification 
    // | sql_parameter_reference
    // | column_reference 
    | target_array_element_specification 
    | dynamic_parameter_specification 
    | embedded_variable_specification
} 
simple_target_specification = {
    host_parameter_name 
    // | sql_parameter_reference 
    // | column_reference 
    // | embedded_variable_name 
}
host_parameter_specification = {
    host_parameter_name ~ indicator_parameter?
}
dynamic_parameter_specification = {
    question_mark 
}
embedded_variable_specification = {
    "embedded_variable_name" ~ indicator_variable?
}
indicator_variable = {
    "INDICATOR" ~ "embedded_variable_name"
} 
indicator_parameter = {
    "INDICATOR" ~ host_parameter_name
} 
target_array_element_specification = {
    target_array_reference 
    ~ left_bracket_or_trigraph ~ simple_value_specification ~ right_bracket_or_trigraph 
}
target_array_reference = {
    "sql_parameter_reference" 
    | "column_reference" 
}
current_collation_specification = {
    "COLLATION" ~ "FOR" ~ left_paren ~ "string_value_expression" ~ right_paren 
}

//6.5 contextually typed value specification
contextually_typed_value_specification = {
    implicitly_typed_value_specification 
    | default_specification 
}
implicitly_typed_value_specification = {
    null_specification 
    | empty_specification 
}
null_specification = {
    "NULL"
}
empty_specification = {
    "ARRAY" ~ left_bracket_or_trigraph ~ right_bracket_or_trigraph 
    | "MULTISET" ~ left_bracket_or_trigraph ~ right_bracket_or_trigraph
} 
default_specification = {
    "DEFAULT"
}

//6.6 identifier chain
identifier_chain = {
    identifier ~ (period ~ identifier)? 
}
basic_identifier_chain = {
    identifier_chain 
}

//6.7 column reference
column_reference = {
    basic_identifier_chain 
    | "MODULE" ~ period ~ qualified_identifier ~ period ~ column_name 
}

//6.9 set function specification
set_function_specification = {
    running_or_final? ~ aggregate_function 
    | grouping_operation 
}
running_or_final = {
    "RUNNING" | "FINAL"
}
grouping_operation = {
    "GROUPING" ~ left_paren ~ column_reference 
    ~ (comma ~ column_reference)* ~ right_paren 
}

//6.10 window function
window_function = {
    window_function_type ~ "OVER" ~ window_name_or_specification 
}
window_function_type = {
    rank_function_type ~ left_paren ~ right_paren 
    | "ROW_NUMBER" ~ left_paren ~ right_paren 
    | aggregate_function 
    | ntile_function 
    | lead_or_lag_function 
    | first_or_last_value_function 
    | nth_value_function 
    | window_row_pattern_measure
} 
rank_function_type = {
    "RANK"
    | "DENSE_RANK"
    | "PERCENT_RANK"
    | "CUME_DIST"
}
ntile_function = {
    "NTILE" ~ left_paren ~ number_of_tiles ~ right_paren
} 
number_of_tiles = {
    simple_value_specification 
    | dynamic_parameter_specification
} 
lead_or_lag_function = {
    lead_or_lag ~ left_paren ~ lead_or_lag_extent 
    ~ (comma ~ offset ~ (comma ~ default_expression)?)? ~ right_paren 
    ~ null_treatment?
}
lead_or_lag = {
    "LEAD" | "LAG"
}
lead_or_lag_extent = {
    value_expression 
}
offset = {
    exact_numeric_literal
} 
default_expression = {
    value_expression 
}
null_treatment = {
    "RESPECT" ~ "NULLS" | "IGNORE" ~ "NULLS"
}
first_or_last_value_function = {
    first_or_last_value ~ left_paren ~ value_expression ~ right_paren ~ null_treatment?
}
first_or_last_value = {
  "FIRST_VALUE" | "LAST_VALUE"
}
nth_value_function = {
    "NTH_VALUE" ~ left_paren ~ value_expression ~ comma ~ nth_row ~ right_paren 
    ~ from_first_or_last? ~ null_treatment?
}
nth_row = {
    simple_value_specification 
    | dynamic_parameter_specification
} 
from_first_or_last = {
    "FROM" ~ "FIRST"
    | "FROM" ~ "LAST"
}
window_name_or_specification = {
    window_name 
    | in_line_window_specification 
}
in_line_window_specification = {
    window_specification 
}
window_row_pattern_measure = {
    measure_name 
}

//6.11 nested window function
nested_window_function = {
    nested_row_number_function 
    | value_of_expression_at_row
} 
nested_row_number_function = {
    "ROW_NUMBER"~ left_paren ~ row_marker ~ right_paren
} 
value_of_expression_at_row = {
    "VALUE_OF" ~ left_paren ~ value_expression ~ "AT" ~ row_marker_expression 
    ~ (comma ~ value_of_default_value) ~ right_paren
} 
row_marker = {
    "BEGIN_PARTITION"
    | "BEGIN_FRAME"
    | "CURRENT_ROW"
    | "FRAME_ROW"
    | "END_FRAME"
    | "END_PARTITION"
}
row_marker_expression = {
    row_marker ~ row_marker_delta? 
}
row_marker_delta = {
    plus_sign ~ row_marker_offset 
    | minus_sign ~ row_marker_offset 
}
row_marker_offset = {
    simple_value_specification 
    | dynamic_parameter_specification
} 
value_of_default_value = {
    value_expression 
}

//6.11 case expression
case_expression = {
    case_abbreviation 
    | case_specification
} 
case_abbreviation = {
    "NULLIF" ~ left_paren ~ value_expression ~ comma ~ value_expression ~ right_paren 
    | "COALESCE" ~ left_paren ~ value_expression 
    ~ (comma ~ value_expression)* ~ right_paren
} 
case_specification = {
    simple_case 
    | searched_case 
}
simple_case = {
    "CASE" ~ case_operand ~ simple_when_clause ~ else_clause? ~ "END"
}
searched_case = {
    "CASE" ~ searched_when_clause  ~ else_clause? ~ "END"
}
simple_when_clause = {
    "WHEN" ~ when_operand_list ~ "THEN" ~ result
} 
searched_when_clause = {
    "WHEN" ~ search_condition ~ "THEN" ~ result
} 
else_clause = {
    "ELSE" ~ result 
}
case_operand = {
    row_value_predicand 
    | overlaps_predicate_part_1
} 
when_operand_list = {
    when_operand ~ (comma ~ when_operand)*
}
when_operand = {
    row_value_predicand 
    | comparison_predicate_part_2 
    | between_predicate_part_2 
    | in_predicate_part_2 
    | character_like_predicate_part_2 
    | octet_like_predicate_part_2 
    | similar_predicate_part_2 
    | regex_like_predicate_part_2 
    | null_predicate_part_2 
    | quantified_comparison_predicate_part_2 
    | normalized_predicate_part_2 
    | match_predicate_part_2 
    | overlaps_predicate_part_2 
    | distinct_predicate_part_2 
    | member_predicate_part_2 
    | submultiset_predicate_part_2 
    | set_predicate_part_2 
    | type_predicate_part_2 
}
result = {
    result_expression 
    | "NULL"
}
result_expression = {
    value_expression 
}

//6.13 cast specification
cast_specification = {
    "CAST" ~ left_paren 
    ~ cast_operand ~ "AS" ~ cast_target 
    ~ ("FORMAT" ~ cast_template)?
    ~ right_paren 
}
cast_operand = {
    value_expression 
    | implicitly_typed_value_specification 
}
cast_target = {
    domain_name 
    | data_type 
}
cast_template = {
    character_string_literal
}

//6.14 next value expression>
next_value_expression = {
    "NEXT" ~ "VALUE" ~ "FOR" ~ sequence_generator_name
}

//6.15 field reference
field_reference = {
    value_expression_primary ~ period ~ field_name 
}

//6.16 subtype treatment
subtype_treatment = {
    "TREAT" ~ left_paren ~ subtype_operand ~ "AS" ~ target_subtype ~ right_paren 
}
subtype_operand = {
    value_expression
} 
target_subtype = {
    path_resolved_user_defined_type_name 
    | reference_type 
}

//6.17 method invocation
method_invocation = {
    direct_invocation 
    | generalized_invocation
} 
direct_invocation = {
    value_expression_primary ~ period ~ method_name ~ sql_argument_list?
}
generalized_invocation = {
    left_paren ~ value_expression_primary ~ "AS" ~ data_type ~ right_paren 
    ~ period ~ method_name ~ sql_argument_list?
}
method_selection = {
    routine_invocation 
}
constructor_method_selection = {
    routine_invocation 
}

//6.18 static method invocation
static_method_invocation = {
    path_resolved_user_defined_type_name ~ double_colon ~ method_name 
    ~ sql_argument_list?
}
static_method_selection = {
    routine_invocation 
}

//6.19 new specification
new_specification = {
    "NEW" ~ path_resolved_user_defined_type_name ~ sql_argument_list 
}
new_invocation = {
    method_invocation 
    | routine_invocation 
}

//6.20 attribute or method reference
attribute_or_method_reference = {  
    value_expression_primary ~ dereference_operator ~ qualified_identifier 
    ~ sql_argument_list?
}
dereference_operator = {
    right_arrow 
}

//6.21 dereference operation
dereference_operation = {
    reference_value_expression ~ dereference_operator ~ attribute_name
}

//6.22 method reference
method_reference = {
    value_expression_primary ~ dereference_operator ~ method_name ~ sql_argument_list 
}

//6.23 reference resolution
reference_resolution = {
    "DEREF" ~ left_paren ~ reference_value_expression ~ right_paren 
}

//6.24 array element reference
array_element_reference = {    
    array_value_expression 
    ~ left_bracket_or_trigraph ~ numeric_value_expression ~ right_bracket_or_trigraph 
}

//6.25 multiset element reference
multiset_element_reference = {
    "ELEMENT" ~ left_paren ~ multiset_value_expression ~ right_paren 
}

//6.26 row pattern navigation operation
row_pattern_navigation_operation = {
    row_pattern_navigation_logical 
    | row_pattern_navigation_physical 
    | row_pattern_navigation_compound
} 
row_pattern_navigation_logical = {
    running_or_final? ~ first_or_last 
    ~ left_paren ~ value_expression ~ (comma ~ logical_offset)* ~ right_paren 
}
row_pattern_navigation_physical = {
    prev_or_next 
    ~ left_paren ~ value_expression ~ (comma ~ physical_offset)? ~ right_paren 
}
row_pattern_navigation_compound = {
    prev_or_next ~ left_paren ~ running_or_final? ~ first_or_last 
    ~ left_paren ~ value_expression ~ (comma ~ logical_offset)? ~ right_paren 
    ~ (comma ~ physical_offset)? ~ right_paren 
}
first_or_last = {
    "FIRST" | "LAST"
}
prev_or_next = {
    "PREV" | "NEXT"
}
logical_offset = {
    simple_value_specification 
    | dynamic_parameter_specification
} 
physical_offset = {
    simple_value_specification 
    | dynamic_parameter_specification 
}

//6.27 json value function
json_value_function = {
    "JSON_VALUE" ~ left_paren 
    ~ json_api_common_syntax 
    ~ json_returning_clause?
    ~ json_value_empty_behavior ~ "ON" ~ "EMPTY" 
    ~ json_value_error_behavior ~ "ON" ~ "ERROR" 
    ~ right_paren 
}
json_returning_clause = {
    "RETURNING" ~ data_type 
}
json_value_empty_behavior = {
    "ERROR"
    | "NULL"
    | "DEFAULT" ~ value_expression
} 
json_value_error_behavior = {
    "ERROR"
    | "NULL"
    | "DEFAULT" ~ value_expression 
}

//6.28 value expression
value_expression = {
    common_value_expression 
    | boolean_value_expression 
    | row_value_expression
}
common_value_expression = {
    numeric_value_expression 
    | string_value_expression 
    | datetime_value_expression 
    | interval_value_expression 
    | user_defined_type_value_expression 
    | reference_value_expression 
    | collection_value_expression
} 
user_defined_type_value_expression = {
    value_expression_primary 
}
reference_value_expression = {
    value_expression_primary 
}
collection_value_expression = {
    array_value_expression 
    | multiset_value_expression 
}

//6.29 numeric value expression
numeric_value_expression = {
    term 
    | "numeric" ~ value_expression ~ plus_sign ~ term 
    | "numeric" ~ value_expression ~ minus_sign ~ term
} 
term = {
    factor 
    | term ~ asterisk ~ factor 
    | term ~ solidus ~ factor
} 
factor = {
    "sign"? ~ numeric_primary
} 
numeric_primary = {
    "value_expression_primary" 
    | numeric_value_function 
}

//6.30 numeric value function
numeric_value_function = {
    position_expression 
    | regex_occurrences_function 
    | regex_position_expression 
    | extract_expression 
    | length_expression 
    | cardinality_expression 
    | max_cardinality_expression 
    | absolute_value_expression 
    | modulus_expression 
    | trigonometric_function 
    | general_logarithm_function 
    | common_logarithm 
    | natural_logarithm 
    | exponential_function 
    | power_function 
    | square_root 
    | floor_function 
    | ceiling_function 
    | width_bucket_function 
    | match_number_function 
}
position_expression = {
    character_position_expression 
    | binary_position_expression 
}
regex_occurrences_function = {
    "OCCURRENCES_REGEX" ~ left_paren 
    ~ xquery_pattern ~ "FLAG" ~ xquery_option_flag
    ~ "IN" ~ regex_subject_string 
    ~ "FROM" ~ "start_position"
    ~ "USING" ~ "char_length_units"  
    ~ right_paren 
}
xquery_pattern = {"character_value_expression"} 
xquery_option_flag = {"character_value_expression"}
regex_subject_string = {"character_value_expression"}
regex_position_expression = {
    "POSITION_REGEX" ~ left_paren 
    ~ regex_position_start_or_after
    ~ xquery_pattern ~ "FLAG" ~ xquery_option_flag  
    ~ "IN" ~ regex_subject_string 
    ~ "FROM" ~ "start_position"  
    ~ "USING" ~ "char_length_units"  
    ~ "OCCURRENCE" ~ regex_occurrence  
    ~ "GROUP" ~ regex_capture_group  
    ~ right_paren    
}
regex_position_start_or_after = {
    "START"
    | "AFTER"
}
regex_occurrence = {numeric_value_expression} 
regex_capture_group = {numeric_value_expression}
character_position_expression = {
    "POSITION" ~ left_paren ~ character_value_expression_1 ~ "IN" ~ character_value_expression_2 
    ~ "USING" ~ "char_length_units" ~ right_paren 
}
character_value_expression_1 = {"character_value_expression"} 
character_value_expression_2 = {"character_value_expression"} 
binary_position_expression = {
    "POSITION" ~ left_paren ~ "IN" ~ right_paren 
}
length_expression = {
    char_length_expression 
    | octet_length_expression 
}
char_length_expression = {
    "CHAR_LENGTH" | "CHARACTER_LENGTH" ~ left_paren ~ "character_value_expression" 
    ~ "USING" ~ "char_length_units" ~ right_paren 
}
octet_length_expression = {
    "OCTET_LENGTH" ~ left_paren ~ "string_value_expression" ~ right_paren 
}
extract_expression = {
    "EXTRACT" ~ left_paren ~ extract_field ~ "FROM" ~ extract_source ~ right_paren 
}
extract_field = {
    "primary_datetime_field" 
    | time_zone_field 
}
time_zone_field = {
    "TIMEZONE_HOUR"
    | "TIMEZONE_MINUTE"
}
extract_source = {
    "datetime_value_expression" 
    | "interval_value_expression" 
}
cardinality_expression = {
    "CARDINALITY" ~ left_paren ~ collection_value_expression ~ right_paren 
}
max_cardinality_expression = {
    "ARRAY_MAX_CARDINALITY" ~ left_paren ~ "array_value_expression" ~ right_paren 
}
absolute_value_expression = {
    "ABS" ~ left_paren ~ numeric_value_expression ~ right_paren 
}
modulus_expression = {
    "MOD" ~ left_paren ~ numeric_value_expression_dividend ~ comma 
    ~ numeric_value_expression_divisor ~ right_paren 
}
numeric_value_expression_dividend = {numeric_value_expression} 
numeric_value_expression_divisor = {numeric_value_expression} 
trigonometric_function = {
    trigonometric_function_name ~ left_paren ~ numeric_value_expression ~ right_paren
}

trigonometric_function_name = {
  "SIN" | "COS" | "TAN" | "SINH" | "COSH" | "TANH" | "ASIN" | "ACOS" | "ATAN"
}
general_logarithm_function = {
    "LOG"~ left_paren ~ general_logarithm_base ~ comma 
    ~ general_logarithm_argument ~ right_paren 
}
general_logarithm_base = {numeric_value_expression} 
general_logarithm_argument = {numeric_value_expression}
common_logarithm = {
    "LOG10" ~ left_paren ~ numeric_value_expression ~ right_paren 
}

natural_logarithm = {
    "LN" ~ left_paren ~ numeric_value_expression ~ right_paren
}
exponential_function = {
    "EXP" ~ left_paren ~ numeric_value_expression ~ right_paren 
}

power_function = {
    "POWER" ~ left_paren ~ numeric_value_expression_base ~ comma 
    ~ numeric_value_expression_exponent ~ right_paren 
}
numeric_value_expression_base = {numeric_value_expression}
numeric_value_expression_exponent = {numeric_value_expression}
square_root = {
    "SQRT" ~ left_paren ~ numeric_value_expression ~ right_paren 
}
floor_function = {
    "FLOOR" ~ left_paren ~ numeric_value_expression ~ right_paren
} 
ceiling_function = {
    "CEIL" | "CEILING" ~ left_paren ~ numeric_value_expression ~ right_paren 
}
width_bucket_function = {
    "WIDTH_BUCKET" ~ left_paren ~ width_bucket_operand ~ comma ~ width_bucket_bound_1 ~ comma 
    ~ width_bucket_bound_2 ~ comma ~ width_bucket_count ~ right_paren 
}
width_bucket_operand = {numeric_value_expression}
width_bucket_bound_1 = {numeric_value_expression} 
width_bucket_bound_2 = {numeric_value_expression} 
width_bucket_count = {numeric_value_expression} 
match_number_function = {
    "MATCH_NUMBER" ~ left_paren ~ right_paren 
}

//6.31 string value expression
string_value_expression = {
    character_value_expression 
    | binary_value_expression 
}
character_value_expression = {
    concatenation
    | character_factor 
}
concatenation = {
    character_value_expression ~ concatenation_operator ~ character_factor 
}
character_factor = {
    character_primary ~ collate_clause?
}
character_primary = {
    value_expression_primary 
    | string_value_function 
}
binary_value_expression = {
    binary_concatenation 
    | binary_factor
} 
binary_factor = {
    binary_primary
} 
binary_primary = {
    value_expression_primary 
    | string_value_function 
}
binary_concatenation = {
    binary_value_expression ~ concatenation_operator ~ binary_factor 
}

//6.32 string value function
string_value_function = {"TODO"}
normal_form = {
    "NFC"
    | "NFD"
    | "NFKC"
    | "NFKD"
}

//6.35 datetime value expression
datetime_value_expression = {
    datetime_term 
    | interval_value_expression ~ plus_sign ~ datetime_term 
    | datetime_value_expression ~ plus_sign ~ interval_term 
    | datetime_value_expression ~ minus_sign ~ interval_term
} 
datetime_term = {
    datetime_factor
} 
datetime_factor = {
    datetime_primary ~ time_zone?
}
datetime_primary = {
    value_expression_primary 
    | datetime_value_function
} 
time_zone = {
    "AT" ~ time_zone_specifier
} 
time_zone_specifier = {
    "LOCAL"
    | "TIME" ~ "ZONE" ~ interval_primary 
}

//6.39
boolean_value_expression = {
    boolean_term
    | boolean_value_expression ~ "OR" ~ boolean_term
}
boolean_term = {
    boolean_factor
    | boolean_term ~ "AND" ~ boolean_factor
}
boolean_factor = {
    "NOT" ~ boolean_test
}
boolean_test = {
    boolean_primary ~ "IS" ~ "NOT" ~ truth_value 
}
truth_value = {
    "TRUE"
    | "FALSE"
    | "UNKNOWN"
}
boolean_primary = {
    predicate
    | boolean_predicand
}
boolean_predicand = {
    parenthesized_boolean_value_expression
    | "nonparenthesized_value_expression_primary"
}
parenthesized_boolean_value_expression = {
    left_paren ~ boolean_value_expression ~ right_paren
}

//6.40 array value expression
array_value_expression = {
    array_concatenation 
    | array_primary 
}
array_concatenation = {
    array_value_expression_1 ~ concatenation_operator ~ array_primary
} 
array_value_expression_1 = {
    array_value_expression 
}
array_primary = {
    array_value_function 
    | value_expression_primary 
}

//6.41 array value function
array_value_function = {
    trim_array_function 
}
trim_array_function = {
    "TRIM_ARRAY" ~ left_paren ~ array_value_expression ~ comma ~ numeric_value_expression ~ right_paren
}

//6.42 array value constructor
array_value_constructor = {
    array_value_constructor_by_enumeration 
    | array_value_constructor_by_query
} 
array_value_constructor_by_enumeration = {
    "ARRAY" ~ left_bracket_or_trigraph ~ array_element_list ~ right_bracket_or_trigraph 
}
array_element_list = {
    array_element ~ (comma ~ array_element)?
}
array_element = {
    value_expression 
}
array_value_constructor_by_query = {
    "ARRAY" ~ table_subquery 
}

//6.43 multiset value expression
multiset_value_expression = {
    multiset_term 
    | multiset_value_expression ~ "MULTISET" ~ "UNION" ~ ("ALL" | "DISTINCT") ~ multiset_term 
    | multiset_value_expression ~ "MULTISET" ~ "EXCEPT" ~ ( "ALL" | "DISTINCT") ~ multiset_term
}
multiset_term = {
    multiset_primary 
    | multiset_term ~ "MULTISET" ~  "INTERSECT" ~ ("ALL" | "DISTINCT") ~ multiset_primary 
}
multiset_primary = {
    multiset_value_function 
    | value_expression_primary 
}

//6.44 multiset value function
multiset_value_function = {
    multiset_set_function 
}
multiset_set_function = {
    "SET" ~ left_paren ~ multiset_value_expression ~ right_paren 
}

//6.45 multiset value constructor
multiset_value_constructor = {
    multiset_value_constructor_by_enumeration 
    | multiset_value_constructor_by_query 
    | table_value_constructor_by_query
} 
multiset_value_constructor_by_enumeration = {
    "MULTISET" ~ left_bracket_or_trigraph ~ multiset_element_list ~ right_bracket_or_trigraph
} 
multiset_element_list = {
    multiset_element ~ (comma ~ multiset_element)?
}
multiset_element = {
    value_expression 
}
multiset_value_constructor_by_query = {
    "MULTISET" ~ table_subquery 
}
table_value_constructor_by_query = {
    "TABLE" ~ table_subquery 
}

//7.1 row value constructor
row_value_constructor = {
    common_value_expression 
    | boolean_value_expression 
    | explicit_row_value_constructor
} 
explicit_row_value_constructor = {
    left_paren ~ row_value_constructor_element ~ comma 
    ~ row_value_constructor_element_list ~ right_paren 
    | "ROW"~ left_paren ~ row_value_constructor_element_list ~ right_paren 
    | row_subquery 
}
row_value_constructor_element_list = {
    row_value_constructor_element ~ (comma ~ row_value_constructor_element)*
}
row_value_constructor_element = {
    value_expression 
}
contextually_typed_row_value_constructor = {
    common_value_expression 
    | boolean_value_expression 
    | contextually_typed_value_specification 
    | left_paren ~ contextually_typed_value_specification ~ right_paren 
    | left_paren ~ contextually_typed_row_value_constructor_element ~ comma 
    ~ contextually_typed_row_value_constructor_element_list ~ right_paren 
    | "ROW" ~ left_paren ~ contextually_typed_row_value_constructor_element_list ~ right_paren
} 
contextually_typed_row_value_constructor_element_list = {
    contextually_typed_row_value_constructor_element 
    ~ (comma ~ contextually_typed_row_value_constructor_element)*
}
contextually_typed_row_value_constructor_element = {
    value_expression 
    | contextually_typed_value_specification 
}
row_value_constructor_predicand = {
    common_value_expression 
    | boolean_predicand 
    | explicit_row_value_constructor 
}

//7.2 row value expression
row_value_expression = {
    row_value_special_case 
    | explicit_row_value_constructor
} 
table_row_value_expression = {
    row_value_special_case 
    | row_value_constructor 
}
contextually_typed_row_value_expression = {
    row_value_special_case 
    | contextually_typed_row_value_constructor 
}
row_value_predicand = {
    row_value_special_case 
    | row_value_constructor_predicand 
}
row_value_special_case = {
    nonparenthesized_value_expression_primary 
}

//7.3
table_value_constructor = {
    "VALUES"
}

//7.6 table reference
table_or_query_name = {
    "TODO"
}
column_name_list = {
    column_name ~ (comma ~ column_name)*
}

//7.8 row pattern measures
row_pattern_measures = {
    "MEASURES" ~ row_pattern_measure_list
} 
row_pattern_measure_list = {
    row_pattern_measure_definition ~ (comma ~ row_pattern_measure_definition)*
}
row_pattern_measure_definition = {
    row_pattern_measure_expression ~ "AS" ~ measure_name 
}
row_pattern_measure_expression = {
    value_expression 
}

//7.9 row pattern common syntax
row_pattern_common_syntax = {"AFTER"}

//7.11 json table
json_table = {
    "JSON_TABLE" ~ left_paren 
    ~ json_api_common_syntax 
    ~ json_table_columns_clause 
    ~ json_table_plan_clause?
    ~ (json_table_error_behavior ~ "ON" ~ "ERROR")?
    ~ right_paren 
}
json_table_columns_clause = {
    "COLUMNS" ~ left_paren 
    ~ json_table_column_definition ~ (comma ~ json_table_column_definition)* 
    ~ right_paren 
}
json_table_column_definition = {
    json_table_ordinality_column_definition 
    | json_table_regular_column_definition 
    | json_table_formatted_column_definition 
    | json_table_nested_columns 
}
json_table_ordinality_column_definition = {
    column_name ~ "FOR" ~ "ORDINALITY"
}
json_table_regular_column_definition = {
    column_name ~ data_type 
    ~ ("PATH" ~ json_table_column_path_specification)?
    ~ (json_table_column_empty_behavior ~ "ON" ~ "EMPTY")?
    ~ (json_table_column_error_behavior ~ "ON" ~ "ERROR")?
}
json_table_column_empty_behavior = {
    "ERROR"
    | "NULL"
    | "DEFAULT" ~ value_expression 
}
json_table_column_error_behavior = {    
    "ERROR"
    | "NULL"
    | "DEFAULT" ~ value_expression 
}
json_table_column_path_specification = {
    json_path_specification
}
json_table_formatted_column_definition = {
    column_name ~ data_type 
    ~ "FORMAT" ~ json_representation 
    ~ ("PATH" ~ json_table_column_path_specification)?
    ~ (json_table_formatted_column_wrapper_behavior ~ "WRAPPER")?
    ~ (json_table_formatted_column_quotes_behavior ~ "QUOTES" ~ ("ON" ~ "SCALAR" ~ "STRING")?)?
    ~ (json_table_formatted_column_empty_behavior ~ "ON" ~ "EMPTY")?
    ~ (json_table_formatted_column_error_behavior ~ "ON" ~ "ERROR")?
}
json_table_formatted_column_wrapper_behavior = {
    "WITHOUT" ~ "ARRAY"? 
    | "WITH" ~ ("CONDITIONAL" | "UNCONDITIONAL")? ~ "ARRAY"? 
}
json_table_formatted_column_quotes_behavior = {
    "KEEP"
    | "OMIT"
}
json_table_formatted_column_empty_behavior = {
    "ERROR"
    | "NULL"
    | "EMPTY" ~ "ARRAY"
    | "EMPTY" ~ "OBJECT"
}
json_table_formatted_column_error_behavior = {
    "ERROR"
    | "NULL"
    | "EMPTY" ~ "ARRAY"
    | "EMPTY" ~ "OBJECT"
}
json_table_nested_columns = {
    "NESTED" ~ "PATH"? ~ json_table_nested_path_specification 
    ~ ("AS" ~ json_table_nested_path_name)?
    ~ json_table_columns_clause
} 
json_table_nested_path_specification = {
    json_path_specification 
}
json_table_nested_path_name = {
    json_table_path_name 
}
json_table_path_name = {
    identifier 
}
json_table_plan_clause = {
    json_table_specific_plan 
    | json_table_default_plan 
}
json_table_specific_plan = {
    "PLAN" ~ left_paren ~ json_table_plan ~ right_paren
} 
json_table_plan = {
    json_table_path_name 
    | json_table_plan_parent_child 
    | json_table_plan_sibling
} 
json_table_plan_parent_child = {
    json_table_plan_outer 
    | json_table_plan_inner 
}
json_table_plan_outer = {
    json_table_path_name ~ "OUTER" ~ json_table_plan_primary
} 
json_table_plan_inner = {
    json_table_path_name ~ "INNER" ~ json_table_plan_primary
} 
json_table_plan_sibling = {
    json_table_plan_union 
    | json_table_plan_cross 
}
json_table_plan_union = {
    json_table_plan_primary ~ "UNION" ~ json_table_plan_primary 
    ~ "UNION" ~ json_table_plan_primary
}
json_table_plan_cross = {
    json_table_plan_primary ~ "CROSS" ~ json_table_plan_primary 
    ~ ("CROSS" ~ json_table_plan_primary)*  
}
json_table_plan_primary = {
    json_table_path_name 
    | left_paren ~ json_table_plan ~ right_paren
} 
json_table_default_plan = {
    "PLAN" ~ "DEFAULT" ~ left_paren 
    ~ json_table_default_plan_choices ~ right_paren
} 
json_table_default_plan_choices = {
    json_table_default_plan_inner_outer 
    ~ (comma ~ json_table_default_plan_union_cross)?
    | json_table_default_plan_union_cross 
    ~ (comma ~ json_table_default_plan_inner_outer)?
}
json_table_default_plan_inner_outer = {
    "INNER" | "OUTER"
}
json_table_default_plan_union_cross = {
    "UNION" | "CROSS"
}
json_table_error_behavior = {
    "ERROR"
    | "EMPTY"
}
json_table_primitive = {
    "JSON_TABLE_PRIMITIVE" ~ left_paren 
    ~ json_api_common_syntax 
    ~ json_table_primitive_columns_clause 
    ~ json_table_error_behavior ~ "ON" ~ "ERROR"
    ~ right_paren 
}
json_table_primitive_columns_clause = {
    "COLUMNS" ~ left_paren 
    ~ json_table_primitive_column_definition 
    ~ (comma ~ json_table_primitive_column_definition)*
    ~ right_paren 
}
json_table_primitive_column_definition = {
    json_table_ordinality_column_definition 
    | json_table_regular_column_definition 
    | json_table_formatted_column_definition 
    | json_table_primitive_chaining_column 
}
json_table_primitive_chaining_column = {
    column_name ~ "FOR" ~ "CHAINING"
}

//7.15 window clause
window_clause = {
    "WINDOW" ~ window_definition_list 
}
window_definition_list = {
    window_definition ~ (comma ~ window_definition)*
}
window_definition = {
    new_window_name ~ "AS" ~ window_specification 
}
new_window_name = {
    window_name 
}
window_specification = {
    left_paren ~ window_specification_details ~ right_paren 
}
window_specification_details = {
    existing_window_name?
    ~ window_partition_clause?
    ~ window_order_clause?
    ~ window_frame_clause?
}
existing_window_name = {
    window_name 
}
window_partition_clause = {
    "PARTITION" ~ "BY" ~ window_partition_column_reference_list
} 
window_partition_column_reference_list = {
    window_partition_column_reference 
    ~ (comma ~ window_partition_column_reference)*
}
window_partition_column_reference = {
    column_reference ~ collate_clause?
}
window_order_clause = {
    "ORDER" ~ "BY" ~ sort_specification_list
} 
window_frame_clause = {
    row_pattern_measures?
    ~ window_frame_units ~ window_frame_extent 
    ~ window_frame_exclusion?
    ~ row_pattern_common_syntax?
}
window_frame_units = {
    "ROWS"
    | "RANGE"
    | "GROUPS"
}
window_frame_extent = {
    window_frame_start 
    | window_frame_between 
}
window_frame_start = {
    "UNBOUNDED" ~ "PRECEDING"
    | window_frame_preceding 
    | "CURRENT" ~ "ROW"
}
window_frame_preceding = {
    unsigned_value_specification ~ "PRECEDING"
}
window_frame_between = {
    "BETWEEN" ~ window_frame_bound_1 ~ "AND" ~ window_frame_bound_2 
}
window_frame_bound_1 = {
    window_frame_bound 
}
window_frame_bound_2 = {
    window_frame_bound 
}
window_frame_bound = {
    window_frame_start 
  | "UNBOUNDED" ~ "FOLLOWING"
  | window_frame_following
} 
window_frame_following = {
    unsigned_value_specification ~ "FOLLOWING"
}
window_frame_exclusion = {
    "EXCLUDE" ~ "CURRENT" ~ "ROW"
    | "EXCLUDE" ~ "GROUP"
    | "EXCLUDE" ~ "TIES"
    | "EXCLUDE" ~ "NO" ~ "OTHERS"
}

//7.16 
query_specification = {
    "SELECT"
}

//7.17 query expression
query_expression = {
    with_clause? ~ query_expression_body 
    ~ order_by_clause? ~ result_offset_clause? ~ fetch_first_clause?
}

//7.18 search or cycle clause
search_or_cycle_clause = {
    search_clause 
    | cycle_clause 
    | search_clause ~ cycle_clause
} 
search_clause = {
    "SEARCH" ~ recursive_search_order ~ "SET" ~ sequence_column
} 
recursive_search_order = {
    "DEPTH" ~ "FIRST" ~ "BY" ~ column_name_list 
    | "BREADTH" ~ "FIRST" ~ "BY" ~ column_name_list
} 
sequence_column = {
    column_name 
}
cycle_clause = {
    "CYCLE" ~ "cycle_column_list" ~ "SET" ~ cycle_mark_column ~ "TO" ~ cycle_mark_value 
    ~ "DEFAULT" ~ non_cycle_mark_value ~ "USING" ~ path_column
} 
cycle_column_list = {
    cycle_column ~ (comma ~ cycle_column)*
}
cycle_column = {
    column_name 
}
cycle_mark_column = {
    column_name 
}
path_column = {
    column_name 
}
cycle_mark_value = {
    value_expression 
}
non_cycle_mark_value = {
    value_expression 
}

//7.19 subquery
scalar_subquery = {
    subquery 
}
row_subquery = {
    subquery 
}
table_subquery = {
    subquery 
}
subquery = {
    left_paren ~ query_expression ~ right_paren 
}

//8.1  predicate
predicate = {
    comparison_predicate 
    | between_predicate 
    | in_predicate 
    | like_predicate 
    | similar_predicate 
    | regex_like_predicate 
    | null_predicate 
    | quantified_comparison_predicate 
    | exists_predicate 
    | unique_predicate
    | normalized_predicate 
    | match_predicate
    | overlaps_predicate 
    | distinct_predicate 
    | member_predicate 
    | submultiset_predicate 
    | set_predicate 
    | type_predicate 
    | period_predicate 
    | json_predicate 
    | json_exists_predicate 
}

//8.2  comparision_predicate
comparison_predicate = {
    row_value_predicand ~ comparison_predicate_part_2
} 
comparison_predicate_part_2 = {
    comp_op ~ row_value_predicand
} 
comp_op = {
    equals_operator 
    | not_equals_operator 
    | less_than_operator 
    | greater_than_operator 
    | less_than_or_equals_operator 
    | greater_than_or_equals_operator
} 

//8.3  between_predicate
between_predicate = {
    row_value_predicand ~ between_predicate_part_2
}
between_predicate_part_2 = {
    "NOT"? ~ "BETWEEN" ~ ("ASYMMETRIC" | "SYMMETRIC")?
    ~ row_value_predicand ~ "AND" ~ row_value_predicand 
}

//8.4  in_predicate
in_predicate = {
    row_value_predicand ~ in_predicate_part_2
} 
in_predicate_part_2 = {
    "NOT"? ~ "IN" ~ in_predicate_value
} 
in_predicate_value = {
    table_subquery 
    | left_paren ~ in_value_list ~ right_paren
} 
in_value_list = {
    row_value_expression ~ (comma ~ row_value_expression)*
}

//8.5  like_predicate
like_predicate = {
    character_like_predicate 
    | octet_like_predicate
} 
character_like_predicate = {
    row_value_predicand ~ character_like_predicate_part_2
} 
character_like_predicate_part_2 = {
    "NOT"? ~ "LIKE" ~ character_pattern ~ ("ESCAPE" ~ escape_character)*
}
character_pattern = {
    character_value_expression
} 
escape_character = {
    character_value_expression
} 
octet_like_predicate = {
    row_value_predicand ~ octet_like_predicate_part_2 
}
octet_like_predicate_part_2 = {
    "NOT"? ~ "LIKE" ~ octet_pattern ~ ("ESCAPE" ~ escape_octet)*
}
octet_pattern = {
    binary_value_expression
} 
escape_octet = {
    binary_value_expression 
}

//8.6  similar_predicate
similar_predicate = {
    row_value_predicand ~ similar_predicate_part_2
} 
similar_predicate_part_2 = {
    "NOT"? ~ "SIMILAR" ~ "TO" ~ similar_pattern ~ ("ESCAPE" ~ escape_character)?
}
similar_pattern = {
    character_value_expression
} 
regular_expression = {
    regular_term 
    | regular_expression ~ vertical_bar ~ regular_term
} 
regular_term = {
    regular_factor 
    | regular_term ~ regular_factor
} 
regular_factor = {
    regular_primary 
  | regular_primary ~ asterisk 
  | regular_primary ~ plus_sign 
  | regular_primary ~ question_mark 
  | regular_primary ~ repeat_factor
} 
repeat_factor = {
    left_brace ~ low_value ~ upper_limit? ~ right_brace 
}
upper_limit = {
    comma ~ high_value?
}
low_value = {
    unsigned_integer
} 
high_value = {
    unsigned_integer
} 
regular_primary = {
    character_specifier 
    | percent 
    | regular_character_set 
    | left_paren ~ regular_expression ~ right_paren
}
character_specifier = {
    non_escaped_character 
    | escaped_character
} 
non_escaped_character = {"TODO"}
escaped_character = {"TODO"}
regular_character_set = {
    underscore 
    | left_bracket ~ character_enumeration+ ~ right_bracket 
    | left_bracket ~ circumflex ~ character_enumeration+ ~ right_bracket 
    | left_bracket ~ character_enumeration_include+
    ~ circumflex ~ character_enumeration_exclude+ ~ right_bracket
}
character_enumeration_include = {
    character_enumeration 
}
character_enumeration_exclude = {
    character_enumeration 
}
character_enumeration = {
    character_specifier 
    | character_specifier ~ minus_sign ~ character_specifier 
    | left_bracket ~ colon ~ regular_character_set_identifier ~ colon ~ right_bracket
}
regular_character_set_identifier = {
    identifier 
}

//8.7  regex_like_predicate
regex_like_predicate = {
    row_value_predicand ~ regex_like_predicate_part_2
} 
regex_like_predicate_part_2 = {
    "NOT"? ~ "LIKE_REGEX" ~ xquery_pattern ~ ("FLAG" ~ xquery_option_flag)?
}

//8.8  null_predicate
null_predicate = {
    row_value_predicand ~ null_predicate_part_2
} 
null_predicate_part_2 = {
    "IS" ~ "NOT"? ~ "NULL"
}

//8.9  quantified_comparison_predicate
quantified_comparison_predicate = {
    row_value_predicand ~ quantified_comparison_predicate_part_2 
}
quantified_comparison_predicate_part_2 = {
    comp_op ~ quantifier ~ table_subquery
} 
quantifier = {
    all 
    | some 
}
all = {
    "ALL"
}
some = {
    "SOME"
    | "ANY"
}

//8.10 exist_predicate
exists_predicate = {
    "EXISTS" ~ table_subquery 
}

//8.11 unique_predicate
unique_predicate = {
    "UNIQUE" ~ table_subquery 
}

//8.12 normalized_predicate
normalized_predicate = {
    row_value_predicand ~ normalized_predicate_part_2 
}
normalized_predicate_part_2 = {
    "IS" ~ "NOT"? ~ normal_form? ~ "NORMALIZED"
}

//8.13 match_predicate
match_predicate = {
    row_value_predicand ~ match_predicate_part_2
} 
match_predicate_part_2 = {
    "MATCH" ~ "UNIQUE"? ~ ("SIMPLE" | "PARTIAL" | "FULL")? ~ table_subquery 
}

//8.14 overlaps_predicate
overlaps_predicate = {
    overlaps_predicate_part_1 ~ overlaps_predicate_part_2 
}
overlaps_predicate_part_1 = {
    row_value_predicand_1 
}
overlaps_predicate_part_2 = {
    "OVERLAPS" ~ row_value_predicand_2
} 
row_value_predicand_1 = {
    row_value_predicand 
}
row_value_predicand_2 = {
    row_value_predicand 
}

//8.15 distinct_predicate
distinct_predicate = {
    row_value_predicand_3 ~ distinct_predicate_part_2
} 
distinct_predicate_part_2 = {
    "IS" ~ "NOT"? ~ "DISTINCT" ~ "FROM" ~ row_value_predicand_4
} 
row_value_predicand_3 = {
    row_value_predicand 
}
row_value_predicand_4 = {
    row_value_predicand 
}

//8.16 member_predicate
member_predicate = {
    row_value_predicand ~ member_predicate_part_2 
}
member_predicate_part_2 = {
    "NOT"? ~ "MEMBER" ~ "OF"? ~ multiset_value_expression 
}

//8.17 submultiset_predicate
submultiset_predicate = {
    row_value_predicand ~ submultiset_predicate_part_2
} 
submultiset_predicate_part_2 = {
    "NOT"? ~ "SUBMULTISET" ~ "OF" ~ multiset_value_expression 
}

//8.18 set_predicate
set_predicate = {
    row_value_predicand ~ set_predicate_part_2
} 
set_predicate_part_2 = {
    "IS" ~ "NOT"? ~ "A" ~ "SET"
}

//8.19 type predicate
type_predicate = {
    row_value_predicand ~ type_predicate_part_2 
}
type_predicate_part_2 = {
    "IS" ~ "NOT"? ~ "OF" ~ left_paren ~ type_list ~ right_paren
} 
type_list = {
    user_defined_type_specification 
    ~ (comma ~ user_defined_type_specification)*  
}
user_defined_type_specification = {
    inclusive_user_defined_type_specification 
    | exclusive_user_defined_type_specification
} 
inclusive_user_defined_type_specification = {
    path_resolved_user_defined_type_name 
}
exclusive_user_defined_type_specification = {
    "ONLY" ~ path_resolved_user_defined_type_name 
}

//8.20 period predicate
period_predicate = {
    period_overlaps_predicate 
    | period_equals_predicate 
    | period_contains_predicate 
    | period_precedes_predicate 
    | period_succeeds_predicate 
    | period_immediately_precedes_predicate 
    | period_immediately_succeeds_predicate 
}
period_overlaps_predicate = {
    period_predicand_1 ~ period_overlaps_predicate_part_2 
}
period_overlaps_predicate_part_2 = {
    "OVERLAPS" ~ period_predicand_2 
}
period_predicand_1 = {
    period_predicand 
}
period_predicand_2 = {
    period_predicand 
}
period_predicand = {
    period_reference 
    | "PERIOD" ~ left_paren ~ period_start_value ~ comma ~ period_end_value ~ right_paren 
}
period_reference = {
    basic_identifier_chain
} 
period_start_value = {
    datetime_value_expression
} 
period_end_value = {
    datetime_value_expression
} 
period_equals_predicate = {
    period_predicand_1 ~ period_equals_predicate_part_2 
}
period_equals_predicate_part_2 = {
    "EQUALS" ~ period_predicand_2 
}
period_contains_predicate = {
    period_predicand_1 ~ period_contains_predicate_part_2 
}
period_contains_predicate_part_2 = {
    "CONTAINS" ~ period_or_point_in_time_predicand
} 
period_or_point_in_time_predicand = {
    period_predicand 
    | datetime_value_expression 
}
period_precedes_predicate = {
    period_predicand_1 ~ period_precedes_predicate_part_2 
}
period_precedes_predicate_part_2 = {
    "PRECEDES" ~ period_predicand_2 
}
period_succeeds_predicate = {
    period_predicand_1 ~ period_succeeds_predicate_part_2 
}
period_succeeds_predicate_part_2 = {
    "SUCCEEDS" ~ period_predicand_2 
}
period_immediately_precedes_predicate = {
    period_predicand_1 ~ period_immediately_precedes_predicate_part_2 
}
period_immediately_precedes_predicate_part_2 = {
    "IMMEDIATELY" ~ "PRECEDES" ~ period_predicand_2 
}
period_immediately_succeeds_predicate = {
    period_predicand_1 ~ period_immediately_succeeds_predicate_part_2 
}
period_immediately_succeeds_predicate_part_2 = {
    "IMMEDIATELY" ~ "SUCCEEDS" ~ period_predicand_2 
}

//8.21 search condition
search_condition = {
    boolean_value_expression 
}

//8.22 json predicate>
json_predicate = {
    string_value_expression ~ json_input_clause?
    ~ "IS" ~ "NOT"? ~ "JSON"
    ~ json_predicate_type_constraint?
    ~ json_key_uniqueness_constraint?
}
json_predicate_type_constraint = {
    "VALUE"
    | "ARRAY"
    | "OBJECT"
    | "SCALAR"
}
json_key_uniqueness_constraint = {
    "WITH" ~ "UNIQUE" ~ "KEYS"?
    | "WITHOUT" ~ "UNIQUE" ~ "KEYS"? 
}

//8.23 json exists predicate>
json_exists_predicate = {
    "JSON_EXISTS" ~ left_paren 
    ~ json_api_common_syntax 
    ~ (json_exists_error_behavior ~ "ON" ~ "ERROR")*
    ~ right_paren 
}
json_exists_error_behavior = {
    "TRUE" | "FALSE" | "UNKNOWN" | "ERROR"
}

//10.1 interval qualifier>
interval_qualifier = {
    start_field ~ "TO" ~ end_field 
    | single_datetime_field
} 
start_field = {
    non_second_primary_datetime_field 
    ~ (left_paren ~ interval_leading_field_precision ~ right_paren)?
}
end_field = {
    non_second_primary_datetime_field 
    | "SECOND" ~ (left_paren ~ interval_fractional_seconds_precision ~ right_paren)?
}
single_datetime_field = {
    non_second_primary_datetime_field 
    ~ (left_paren  ~ interval_leading_field_precision ~ right_paren)
    ~ ("SECOND" ~ left_paren ~ interval_leading_field_precision
    ~ (comma ~ interval_fractional_seconds_precision)? ~ right_paren)?
}
primary_datetime_field = {
    non_second_primary_datetime_field 
    | "SECOND"
}
non_second_primary_datetime_field = {
    "YEAR"
    | "MONTH"
    | "DAY"
    | "HOUR"
    | "MINUTE"
}
interval_fractional_seconds_precision = {
    unsigned_integer 
}
interval_leading_field_precision = {
    unsigned_integer 
}

//10.9 aggregate function
aggregate_function = {
    "COUNT" ~ left_paren ~ asterisk ~ right_paren ~ filter_clause?
    | general_set_function ~ filter_clause?
    | binary_set_function ~ filter_clause?
    | ordered_set_function ~ filter_clause?
    | array_aggregate_function ~ filter_clause?
    | row_pattern_count_function ~ filter_clause?
    | json_aggregate_function ~ filter_clause?
}
general_set_function = {
    set_function_type ~ left_paren ~ set_quantifier?
    ~ value_expression ~ right_paren
} 
set_function_type = {
    computational_operation
} 
computational_operation = {
    "AVG"
    | "MAX"
    | "MIN"
    | "SUM"
    | "EVERY"
    | "ANY"
    | "SOME"
    | "COUNT"
    | "STDDEV_POP"
    | "STDDEV_SAMP"
    | "VAR_SAMP"
    | "VAR_POP"
    | "COLLECT"
    | "FUSION"
    | "INTERSECTION"
}
set_quantifier = {
    "DISTINCT"
    | "ALL"
}
filter_clause = {
    "FILTER" ~ left_paren ~ "WHERE" ~ search_condition ~ right_paren
} 
binary_set_function = {
    binary_set_function_type ~ left_paren ~ dependent_variable_expression ~ comma 
    ~ independent_variable_expression ~ right_paren
} 
binary_set_function_type = {
    "COVAR_POP"
    | "COVAR_SAMP"
    | "CORR"
    | "REGR_SLOPE"
    | "REGR_INTERCEPT"
    | "REGR_COUNT"
    | "REGR_R2"
    | "REGR_AVGX"
    | "REGR_AVGY"
    | "REGR_SXX"
    | "REGR_SYY"
    | "REGR_SXY"
}
dependent_variable_expression = {
    numeric_value_expression 
}
independent_variable_expression = {
    numeric_value_expression 
}
ordered_set_function = {
    hypothetical_set_function 
    | inverse_distribution_function 
    | listagg_set_function
} 
hypothetical_set_function = {
    rank_function_type ~ left_paren 
    ~ hypothetical_set_function_value_expression_list ~ right_paren 
    ~ within_group_specification
} 
within_group_specification = {
    "WITHIN" ~ "GROUP"~ left_paren ~ "ORDER" ~ "BY" ~ sort_specification_list ~ right_paren
} 
hypothetical_set_function_value_expression_list = {
    value_expression ~ (comma ~ value_expression)*  
}
inverse_distribution_function = {
    inverse_distribution_function_type ~ left_paren 
    ~ inverse_distribution_function_argument ~ right_paren 
    ~ within_group_specification
} 
inverse_distribution_function_argument = {
    numeric_value_expression 
}
inverse_distribution_function_type = {
    "PERCENTILE_CONT"
    | "PERCENTILE_DISC"
}
listagg_set_function = {
    "LISTAGG" ~ left_paren ~ set_quantifier? ~ character_value_expression 
    ~ comma ~ listagg_separator ~ listagg_overflow_clause? ~ right_paren 
    ~ within_group_specification
} 
listagg_separator = {
    character_string_literal 
}
listagg_overflow_clause = {
    "ON" ~ "OVERFLOW" ~ overflow_behavior 
}
overflow_behavior = {
    "ERROR"
    | "TRUNCATE" ~ listagg_truncation_filler? ~ listagg_count_indication 
}
listagg_truncation_filler = {
    character_string_literal
} 
listagg_count_indication = {
    "WITH" ~ "COUNT"
    | "WITHOUT" ~ "COUNT"
}
array_aggregate_function = {
    "ARRAY_AGG"
    ~ left_paren ~ value_expression ~ ("ORDER" ~ "BY" ~ sort_specification_list)? ~ right_paren 
}
row_pattern_count_function = {
    "COUNT" ~ left_paren ~ row_pattern_variable_name ~ period ~ asterisk ~ right_paren 
}

//10.10 sort specification list
sort_specification_list = {
    sort_specification ~ (comma ~ sort_specification)*
}
sort_specification = {
    sort_key ~ ordering_specification? ~ null_ordering?
}
sort_key = {
    value_expression
} 
ordering_specification = {
    "ASC"
    | "DESC"
}
null_ordering = {
    "NULLS" ~ "FIRST"
    | "NULLS" ~ "LAST"
}

//10.11 json aggregate function
json_aggregate_function = {
    json_object_aggregate_constructor 
    | json_array_aggregate_constructor
} 
json_object_aggregate_constructor = {
    "JSON_OBJECTAGG" ~ left_paren 
    ~ json_name_and_value 
    ~ json_constructor_null_clause?
    ~ json_key_uniqueness_constraint?
    ~ json_output_clause?
    ~ right_paren 
}
json_array_aggregate_constructor = {
    "JSON_ARRAYAGG" ~ left_paren 
    ~ json_value_expression 
    ~ json_array_aggregate_order_by_clause?
    ~ json_constructor_null_clause?
    ~ json_output_clause?
    ~ right_paren 
}
json_array_aggregate_order_by_clause = {
    "ORDER" ~ "BY" ~ sort_specification_list 
}

//10.12 json value expression
json_value_expression = {
    value_expression ~ json_input_clause?
}
json_input_clause = {
    "FORMAT" ~ json_representation 
}

//10.14 json api common syntax
json_api_common_syntax = {
    json_context_item ~ comma ~ json_path_specification ~ ("AS" ~ json_table_path_name)*
    ~ json_passing_clause?
}
json_context_item = {
    json_value_expression
} 
json_path_specification = {
    character_string_literal 
}
json_passing_clause = {
    "PASSING" ~ json_argument ~ (comma ~ json_argument)*
}
json_argument = {
    json_value_expression ~ "AS" ~ identifier 
}

//11.3 table defenition
table_definition = {
    "CREATE" ~ table_scope? ~ "TABLE" ~ table_name ~ table_contents_source 
    ~ ("WITH" ~ system_versioning_clause ~ "ON")? 
    ~ ("COMMIT" ~ table_commit_action ~ "ROWS")?
}
table_contents_source = {
    table_element_list 
    | typed_table_clause 
    | as_subquery_clause
}
table_scope = {global_or_local ~ "TEMPORARY"}
global_or_local = {"GLOBAL" | "LOCAL"}
system_versioning_clause = {"SYSTEM" ~ "VERSIONING"}
table_commit_action = {"PRESERVE" | "DELETE"}
table_element_list = {
    left_paren ~ table_element ~ comma ~ table_element ~ right_paren
}
table_element = {
    // column_definition
    table_period_definition
    // | table_constraint_definition
    | like_clause
}
typed_table_clause = {
    "OF" ~ "TODO" ~ subtable_clause 
    ~ typed_table_element_list
}
typed_table_element_list = {
    left_paren ~ typed_table_element
    ~ comma ~ typed_table_element ~ right_paren
}
typed_table_element = {
    column_options
    | self_referencing_column_specification
}
self_referencing_column_specification = {
    "REF" ~ "IS" ~ self_referencing_column_name ~ reference_generation 
}
reference_generation = {
    "SYSTEM" ~ "GENERATED"
    | "USER" ~ "GENERATED"
    | "DERIVED"
}
self_referencing_column_name = {column_name}
column_options = {column_name ~ "WITH" ~ "OPTIONS"}
subtable_clause = {"UNDER" ~ supertable_clause}
supertable_clause = {supertable_name}
supertable_name = {table_name}
like_clause = {"LIKE" ~ table_name ~ like_options}
like_options = {like_option}
like_option = {
    identity_option
    | column_default_option
    | generation_option
}
identity_option = {
    "INCLUDING" ~ "IDENTITY"
    | "EXCLUDING" ~ "IDENTITY"
}
column_default_option = {
    "INCLUDING" ~ "DEFAULTS"
    | "EXCLUDING" ~ "DEFAULTS"
}
generation_option = {
    "INCLUDING" ~ "GENERATED"
    | "EXCLUDING" ~ "GENERATED"
}
as_subquery_clause = {
    left_paren ~ right_paren ~ "AS" ~ table_subquery 
    ~ with_or_without_data
}
with_or_without_data = {"WITH" ~ "NO" ~ "DATA" | "WITH" ~ "DATA"}
table_period_definition = {
    system_or_application_time_period_specification
    ~ left_paren ~ period_begin_column_name ~ comma ~ period_end_column_name ~ right_paren
}
system_or_application_time_period_specification = {system_time_period_specification | application_time_period_specification}
system_time_period_specification = {"PERIOD" ~ "FOR" ~ "SYSTEM_TIME"}
application_time_period_specification = {"PERIOD" ~ "FOR" ~ application_time_period_name}
application_time_period_name = {identifier}
period_begin_column_name = {column_name}
period_end_column_name = {column_name}

//11.10
alter_table_statement = {"TODO"}

//11.31 drop table statement
drop_table_statement = {
    "DROP" ~ "TABLE" ~ table_name ~ drop_behavior? 
}

//11.32 view definition
view_definition = {
    "CREATE" ~ "RECURSIVE" ~ "VIEW" ~ table_name ~ view_specification 
    ~ "AS" ~ query_expression ~ ("WITH" ~ levels_clause?)? ~ "CHECK" ~ "OPTION"
}
view_specification = {
    regular_view_specification 
    | referenceable_view_specification
} 
regular_view_specification = {
    left_paren ~ view_column_list ~ right_paren
}
referenceable_view_specification = {
    "OF" ~ path_resolved_user_defined_type_name ~ subview_clause
    ~ view_element_list?
}
subview_clause = {
    "UNDER" ~ table_name 
}
view_element_list = {
    left_paren ~ view_element ~ (comma ~ view_element)* ~ right_paren 
}
view_element = {
    self_referencing_column_specification 
    | view_column_option 
}
view_column_option = {
    column_name ~ "WITH" ~ "OPTIONS" ~ scope_clause
} 
levels_clause = {
    "CASCADED"
    | "LOCAL"
}
view_column_list = {
    column_name_list 
}

//11.33
drop_view_statement = {"TODO"}

//11.34
domain_definition = {"TODO"}

//11.35
alter_domain_statement = {"TODO"}

//11.36
set_domain_default_clause = {"TODO"}

//11.37
drop_domain_default_clause = {"TODO"}

//11.38
add_domain_constraint_definition = {"TODO"}

//11.39
drop_domain_constraint_definition = {"TODO"}

//11.40 drop domain statement
drop_domain_statement = {"TODO"}

//11.41 character set definition
character_set_definition = {"TODO"}

//11.42 drop character set statement
drop_character_set_statement = {"TODO"}

//11.43 collation definition
collation_definition = {"TODO"}

//11.44
drop_collation_statement = {"TODO"}

//11.45
transliteration_definition = {"TODO"}

//11.46
drop_transliteration_statement = {"TODO"}

//11.47
assertion_definition = {"TODO"}

//11.48
drop_assertion_statement = {"TODO"}

//11.49
trigger_definition = {"TODO"}

//11.50
drop_trigger_statement = {"TODO"}

//11.51
user_defined_type_definition = {"TODO"}

//11.53
alter_type_statement = {"TODO"}

//11.59
drop_data_type_statement = {"TODO"}

//11.60
sql_invoked_routine = {"TODO"}

//11.61
alter_routine_statement = {"TODO"}

//11.62 drop routine statement
drop_routine_statement = {"TODO"}

//11.63
user_defined_cast_definition = {"TODO"}

//11.64
drop_user_defined_cast_statement = {"TODO"}

//11.65
user_defined_ordering_definition = {"TODO"}

//11.66
drop_user_defined_ordering_statement = {"TODO"}

//11.67
transform_definition = {"TODO"}

//11.68
alter_transform_statement = {"TODO"}

//11.69 add transform element list
add_transform_element_list = {"TODO"}

//11.70 drop transform element list
drop_transform_element_list = {"TODO"}

//11.71
drop_transform_statement = {"TODO"}

//11.72
sequence_generator_definition = {"TODO"}

//11.73
alter_sequence_generator_statement = {"TODO"}

//11.74 drop sequence generator statement
drop_sequence_generator_statement = {"TODO"}

//12.1 
grant_statement = {"TODO"}
//12.4
role_definition = {"TODO"}
//12.6
drop_role_statement = {"TODO"}
//12.7
revoke_statement = {"TODO"}

//14
with_clause = {
    "WITH" ~ "RECURSIVE"? ~ with_list 
}
with_list = {
    with_list_element ~ (comma ~ with_list_element)*
}
with_list_element = {
    query_name ~ (left_paren ~ with_column_list ~ right_paren)?
    ~ "AS" ~ table_subquery ~ search_or_cycle_clause?
}
with_column_list = {
    column_name_list
} 
query_expression_body = {
    query_term 
    | "UNION" ~ ("ALL" | "DISTINCT")
    ~ corresponding_spec? ~ query_term 
    | "EXCEPT" ~ ("ALL" | "DISTINCT")
    ~ corresponding_spec? ~ query_term
} 
query_term = {
    query_primary 
    | "INTERSECT" ~ ("ALL" | "DISTINCT")
    ~ corresponding_spec? ~ query_primary 
}
query_primary = {
    simple_table ~ left_paren ~ query_expression_body 
    ~ order_by_clause? ~ result_offset_clause? ~ fetch_first_clause?
    ~ right_paren
} 
simple_table = {
    query_specification 
    | table_value_constructor 
    | explicit_table
} 
explicit_table = {
    "TABLE" ~ table_or_query_name
} 
corresponding_spec = {
    "CORRESPONDING" ~ ("BY" ~ left_paren ~ corresponding_column_list ~ right_paren)?
}
corresponding_column_list = {
    column_name_list 
}
order_by_clause = {
    "ORDER" ~ "BY" ~ sort_specification_list
} 
result_offset_clause = {
    "OFFSET" ~ offset_row_count ~ ("ROW" | "ROWS")
}
fetch_first_clause = {
    "FETCH" ~ ("FIRST" | "NEXT") ~ fetch_first_quantity? 
    ~ ("ROW" | "ROWS") ~ ("ONLY" | "WITH" ~ "TIES")
}
fetch_first_quantity = {
    fetch_first_row_count 
    | fetch_first_percentage
} 
offset_row_count = {
    simple_value_specification
} 
fetch_first_row_count = {
    simple_value_specification
} 
fetch_first_percentage = {
    simple_value_specification ~ "PERCENT"
}

//16.1 call statement
call_statement = {"CALL" ~ "routine_invocation"}

//16.2 return statement
return_statement = {"RETURN" ~ return_value}
return_value = {value_expression | "NULL"}

//6.33 json value constructor
json_value_constructor = {
    json_object_constructor 
    | json_array_constructor
} 
json_object_constructor = {
    "JSON_OBJECT" ~ left_paren 
    ~ json_name_and_value ~ (comma ~ json_name_and_value)*
    ~ json_constructor_null_clause?
    ~ json_key_uniqueness_constraint?
    ~ json_output_clause?
    ~ right_paren 
}
json_name_and_value = {
    "KEY" ~ json_name ~ "VALUE" ~ json_value_expression 
    | json_name ~ colon ~ json_value_expression 
}
json_name = {
    character_value_expression 
}
json_constructor_null_clause = {
    "NULL" ~ "ON" ~ "NULL"
    | "ABSENT" ~ "ON" ~ "NULL"
}
json_array_constructor = {
    json_array_constructor_by_enumeration 
    | json_array_constructor_by_query
} 
json_array_constructor_by_enumeration = {
    "JSON_ARRAY" ~ left_paren 
    ~ (json_value_expression ~ (comma ~ json_value_expression)* 
    ~ json_constructor_null_clause?)?
    ~ json_output_clause?
    ~ right_paren 
}
json_array_constructor_by_query = {
    "JSON_ARRAY" ~ left_paren 
    ~ query_expression 
    ~ json_input_clause?  
    ~ json_constructor_null_clause? 
    ~ json_output_clause?
    ~ right_paren 
}

//6.36 datetime value function
datetime_value_function = {
    current_date_value_function 
    | current_time_value_function 
    | current_timestamp_value_function 
    | current_local_time_value_function 
    | current_local_timestamp_value_function 
}
current_date_value_function = {
    "CURRENT_DATE"
}
current_time_value_function = {
    "CURRENT_TIME" ~ (left_paren ~ time_precision ~ right_paren)?
}
current_local_time_value_function = {
    "LOCALTIME" ~ (left_paren ~ time_precision ~ right_paren)?
}
current_timestamp_value_function = {
    "CURRENT_TIMESTAMP" ~ (left_paren ~ timestamp_precision ~ right_paren)?
}
current_local_timestamp_value_function = {
    "LOCALTIMESTAMP" ~ (left_paren ~ timestamp_precision ~ right_paren)?
}

//6.37 interval value expression
interval_value_expression = {
    interval_term 
    | interval_value_expression_1 ~ plus_sign ~ interval_term_1 
    | interval_value_expression_1 ~ minus_sign ~ interval_term_1 
    | left_paren ~ datetime_value_expression ~ minus_sign ~ datetime_term ~ right_paren 
    ~ interval_qualifier 
}
interval_term = {
    interval_factor
    | interval_term_2 ~ asterisk ~ factor 
    | interval_term_2 ~ solidus ~ factor 
    | term ~ asterisk ~ interval_factor 
}
interval_factor = {
    sign? ~ interval_primary 
}
interval_primary = {
    value_expression_primary ~ interval_qualifier?
    | interval_value_function 
}
interval_value_expression_1 = {
    interval_value_expression 
}
interval_term_1 = {
    interval_term 
}
interval_term_2 = {
    interval_term
} 

//6.38 interval value function>
interval_value_function = {
    interval_absolute_value_function
} 
interval_absolute_value_function = {
    "ABS" ~ left_paren ~ interval_value_expression ~ right_paren 
}

//10.4 routine invocation
routine_invocation = {routine_name ~ sql_argument_list}
routine_name = {schema_name ~ period ~ qualified_identifier}
sql_argument_list = {left_paren ~ sql_argument ~ comma ~ sql_argument ~ right_paren}
sql_argument = {
    value_expression
    | generalized_expression
    | target_specification
    | "contextually_typed_value_specification"
    | named_argument_specification
}
generalized_expression = {
    value_expression ~ "AS" ~ "TODO"
}

named_argument_specification = {sql_parameter_name ~ "named_argument_assignment_token" ~ named_argument_sql_argument}
named_argument_sql_argument = {
    value_expression
    | target_specification
    | "contextually_typed_value_specification"
}

//10.5 character set specification
character_set_specification = {
    standard_character_set_name 
    | implementation_defined_character_set_name 
    | user_defined_character_set_name
} 
standard_character_set_name = {
    character_set_name 
}
implementation_defined_character_set_name = {
    character_set_name 
}
user_defined_character_set_name = {
    character_set_name 
}

//10.7 collate clause
collate_clause = {
    "COLLATE" ~ collation_name
} 

//10.13 json output clause
json_output_clause = {
    "RETURNING" ~ data_type ~ ("FORMAT" ~ json_representation)?
}
json_representation = {
    "JSON" ~ ("ENCODING" ~ ("UTF8" | "UTF16" | "UTF32"))?
}

//11 schema definition and manipulation
//11.1 schema definition
schema_definition = {
    "CREATE" ~ "SCHEMA" ~ schema_name_clause 
    ~ schema_character_set_or_path?
    ~ schema_element*
}
schema_character_set_or_path = {
    schema_character_set_specification 
    | schema_path_specification 
    | schema_character_set_specification ~ schema_path_specification 
    | schema_path_specification ~ schema_character_set_specification 
}
schema_name_clause = {
    schema_name 
    | "AUTHORIZATION" ~ schema_authorization_identifier 
    | schema_name ~ "AUTHORIZATION" ~ schema_authorization_identifier
} 
schema_authorization_identifier = {authorization_identifier}
schema_character_set_specification = {
    "DEFAULT" ~ "CHARACTER" ~ "SET" ~ "character_set_specification"
} 
schema_path_specification = {"path_specification"}
schema_element = {
    "TODO"
    // table_definition 
    // | view_definition 
    // | domain_definition 
    // | character_set_definition 
    // | collation_definition 
    // | transliteration_definition 
    // | assertion_definition 
    // | trigger_definition 
    // | user_defined_type_definition 
    // | user_defined_cast_definition 
    // | user_defined_ordering_definition 
    // | transform_definition 
    // | schema_routine 
    // | sequence_generator_definition 
    // | grant_statement 
    // | role_definition
}
//11.2 drop schema statement
drop_schema_statement = {
    "DROP" ~ "SCHEMA" ~ schema_name ~ drop_behavior 
}
drop_behavior = {
    "CASCADE"
    | "RESTRICT"
}

//13.4 sql procedure statement
sql_procedure_statement = {
    sql_executable_statement
} 
sql_executable_statement = {
    sql_schema_statement 
    | sql_data_statement 
    | sql_control_statement 
    | sql_transaction_statement 
    | sql_connection_statement 
    | sql_session_statement 
    | sql_diagnostics_statement 
    | sql_dynamic_statement 
}
sql_schema_statement = {
    sql_schema_definition_statement 
    | sql_schema_manipulation_statement
} 
sql_schema_definition_statement = {
    schema_definition 
    | table_definition 
    | view_definition 
    | sql_invoked_routine 
    | grant_statement 
    | role_definition 
    | domain_definition 
    | character_set_definition 
    | collation_definition 
    | transliteration_definition 
    | assertion_definition 
    | trigger_definition 
    | user_defined_type_definition 
    | user_defined_cast_definition
    | user_defined_ordering_definition 
    | transform_definition 
    | sequence_generator_definition 
}
sql_schema_manipulation_statement = {
    drop_schema_statement 
    | alter_table_statement 
    | drop_table_statement 
    | drop_view_statement 
    | alter_routine_statement 
    | drop_routine_statement 
    | drop_user_defined_cast_statement 
    | revoke_statement 
    | drop_role_statement 
    | alter_domain_statement 
    | drop_domain_statement 
    | drop_character_set_statement 
    | drop_collation_statement 
    | drop_transliteration_statement 
    | drop_assertion_statement 
    | drop_trigger_statement 
    | alter_type_statement 
    | drop_data_type_statement 
    | drop_user_defined_ordering_statement 
    | alter_transform_statement 
    | drop_transform_statement 
    | alter_sequence_generator_statement 
    | drop_sequence_generator_statement
} 
sql_data_statement = {
    open_statement 
    | fetch_statement 
    | close_statement 
    | select_statement_single_row 
    | free_locator_statement 
    | hold_locator_statement 
    | sql_data_change_statement
} 
sql_data_change_statement = {
    delete_statement_positioned 
    | delete_statement_searched 
    | insert_statement 
    | update_statement_positioned 
    | update_statement_searched 
    | truncate_table_statement 
    | merge_statement 
}
sql_control_statement = {
    call_statement 
    | return_statement
} 
sql_transaction_statement = {
    start_transaction_statement 
    | set_transaction_statement 
    | set_constraints_mode_statement 
    | savepoint_statement 
    | release_savepoint_statement 
    | commit_statement 
    | rollback_statement
} 
sql_connection_statement = {
    connect_statement 
    | set_connection_statement 
    | disconnect_statement 
}
sql_session_statement = {
    set_session_user_identifier_statement 
    | set_role_statement 
    | set_local_time_zone_statement 
    | set_session_characteristics_statement 
    | set_catalog_statement 
    | set_schema_statement 
    | set_names_statement 
    | set_path_statement 
    | set_transform_group_statement 
    | set_session_collation_statement 
}
sql_diagnostics_statement = {
    get_diagnostics_statement
} 
sql_dynamic_statement = {
    sql_descriptor_statement 
    | prepare_statement 
    | deallocate_prepared_statement 
    | describe_statement 
    | execute_statement 
    | execute_immediate_statement 
    | sql_dynamic_data_statement 
    | copy_descriptor_statement 
    | pipe_row_statement 
}
sql_dynamic_data_statement = {
    allocate_extended_dynamic_cursor_statement 
    | allocate_received_cursor_statement 
    | dynamic_open_statement 
    | dynamic_fetch_statement 
    | dynamic_close_statement 
    | dynamic_delete_statement_positioned
    | dynamic_update_statement_positioned 
}
sql_descriptor_statement = {
    allocate_descriptor_statement 
    | deallocate_descriptor_statement 
    | set_descriptor_statement 
    | get_descriptor_statement 
}

//14.3
cursor_specification = {
    updatability_clause
}
updatability_clause = {
    "FOR" ~ ("READ" ~ "ONLY" | "UPDATE" ~ ("OF")?)
}

//14.4 open statement
open_statement = {
    "OPEN" ~ cursor_name
} 

//14.5 fetch statement
fetch_statement = {"TODO"}

//14.6 close statement
close_statement = {"TODO"}

//14.7
select_statement_single_row = {"TODO"}

//14.8 delete statement: positioned
delete_statement_positioned = {"TODO"}

//14.9 delete statement: searched
delete_statement_searched = {
    "DELETE" ~ "FROM" 
}

//14.10 truncate table statement
truncate_table_statement = {
    "TRUNCATE" ~ "TABLE"
}

//14.11 insert statement
insert_statement = {
    "INSERT" ~ "INTO"
}

//14.12 merge statement
merge_statement = {
    "MERGE" ~ "INTO"
}

//14.13 update statement: positioned
update_statement_positioned = {"TODO"}

//14.14 update statement: searched
update_statement_searched = {
    "UPDATE"
}

//14.16 temporary table declaration
temporary_table_declaration = {
    "DECLARE" ~ "LOCAL" ~ "TEMPORARY" ~ "TABLE" ~ table_name ~ table_element_list 
    ~ ("ON" ~ "COMMIT" ~ table_commit_action ~ "ROWS")?
}

//14.17 free locator statement
free_locator_statement = {"TODO"}

//14.18 hold locator statement
hold_locator_statement = {"TODO"}

//17.1 start transaction statement
start_transaction_statement = {
    "START" ~ "TRANSACTION" ~ transaction_characteristics?
}

//17.2 set transaction statement
set_transaction_statement = {
    "SET" ~ "LOCAL"? ~ "TRANSACTION" ~ transaction_characteristics 
}

//17.3 transaction characteristics
transaction_characteristics = {
    transaction_mode ~ (comma ~ transaction_mode)*
}
transaction_mode = {
    isolation_level 
    | transaction_access_mode 
    | diagnostics_size
} 
transaction_access_mode = {
    "READ" ~ "ONLY"
    | "READ" ~ "WRITE"
}
isolation_level = {
    "ISOLATION" ~ "LEVEL" ~ level_of_isolation
} 
level_of_isolation = {
    "READ" ~ "UNCOMMITTED"
    | "READ" ~ "COMMITTED"
    | "REPEATABLE" ~ "READ"
    | "SERIALIZABLE"
}
diagnostics_size = {
    "DIAGNOSTICS" ~ "SIZE" ~ number_of_conditions
} 
number_of_conditions = {simple_value_specification}

//17.4 set constraints mode statement
set_constraints_mode_statement = {
    "SET" ~ "CONSTRAINTS" ~ constraint_name_list ~ ("DEFERRED" | "IMMEDIATE")
}
constraint_name_list = {
    "ALL"
    | constraint_name ~ (comma ~ constraint_name)*
}

//17.5 savepoint statement
savepoint_statement = {
    "SAVEPOINT" ~ savepoint_specifier
} 
savepoint_specifier = {
    savepoint_name 
}
//17.6 release savepoint statement
release_savepoint_statement = {  
    "RELEASE" ~ "SAVEPOINT" ~ savepoint_specifier 
}
//17.7 commit statement
commit_statement = {
    "COMMIT" ~ "WORK"? ~ ("AND" ~ "NO"? ~ "CHAIN")?
}
//17.8 rollback statement
rollback_statement = {
    "ROLLBACK" ~ "WORK"? ~ ("AND" ~ "NO"? ~ "CHAIN")? ~ savepoint_clause?
}
savepoint_clause = {
    "TO" ~ "SAVEPOINT" ~ savepoint_specifier 
}
//18.1 connect statement
connect_statement = {
    "CONNECT" ~ connection_target
}
connection_target = {
    sql_server_name ~ ("AS" ~ connection_name)? ~ ("USER" ~ connection_user_name)?
    | "DEFAULT"
}

//18.2 set connection statement
set_connection_statement = {
    "SET" ~ "CONNECTION" ~ connection_object
} 
connection_object = {
    "DEFAULT"
    | connection_name 
}

//18.3 disconnect statement
disconnect_statement = {
    "DISCONNECT" ~ disconnect_object
} 
disconnect_object = { 
    connection_object
    | "ALL"
    | "CURRENT"
}

//19.1 set session characteristics statement
set_session_characteristics_statement = {
    "SET" ~ "SESSION" ~ "CHARACTERISTICS" ~ "AS" ~ session_characteristic_list
} 
session_characteristic_list = {
    session_characteristic ~ (comma ~ session_characteristic)*
}
session_characteristic = {session_transaction_characteristics} 
session_transaction_characteristics = {
    "TRANSACTION" ~ transaction_mode ~ (comma ~ transaction_mode)*
}
//19.2 set session user identifier statement
set_session_user_identifier_statement = {
    "SET" ~ "SESSION" ~ "AUTHORIZATION" ~ value_specification
} 
//19.3 set role statement
set_role_statement = {
    "SET" ~ "ROLE" ~ role_specification
} 
role_specification = {
    value_specification 
    | "NONE"
}
//19.4 set local time zone statement
set_local_time_zone_statement = {
    "SET" ~ "TIME" ~ "ZONE" ~ set_time_zone_value
} 
set_time_zone_value = {
    "LOCAL"
}

//19.5 set catalog statement
set_catalog_statement = {
    "SET" ~ catalog_name_characteristic
} 
catalog_name_characteristic = {
    "CATALOG" ~ value_specification 
}

//19.6 set schema statement
set_schema_statement = {
    "SET" ~ schema_name_characteristic
} 
schema_name_characteristic = {
    "SCHEMA" ~ value_specification 
}

//19.7 set names statement
set_names_statement = {
    "SET" ~ character_set_name_characteristic
} 
character_set_name_characteristic = {
    "NAMES" ~ value_specification
}

//19.8 set path statement
set_path_statement = {
    "SET" ~ sql_path_characteristic
} 
sql_path_characteristic = {
    "PATH" ~ value_specification 
}

//19.9 <set transform group statement>
set_transform_group_statement = {
    "SET" ~ transform_group_characteristic
} 
transform_group_characteristic = {
    "DEFAULT" ~ "TRANSFORM" ~ "GROUP" ~ value_specification 
    | "TRANSFORM" ~ "GROUP" ~ "FOR" ~ "TYPE" ~ value_specification 
}

//19.10 set session collation statement
set_session_collation_statement = {
    "SET" ~ "COLLATION" ~ collation_specification ~ ("FOR")?
    | "SET" ~ "NO" ~ "COLLATION" ~ ("FOR")?
}
collation_specification = {value_specification} 

//20.2
allocate_descriptor_statement = {"TODO"}
//20.3
deallocate_descriptor_statement = {"TODO"}
//20.4
get_descriptor_statement = {"TODO"}
//20.5
set_descriptor_statement = {"TODO"}
//20.6
copy_descriptor_statement = {"TODO"}
//20.7
prepare_statement = {"TODO"}
//20.8
cursor_attributes = {"TODO"}
//20.9
deallocate_prepared_statement = {"TODO"}
//20.10
describe_statement = {"TODO"}
//20.11
input_using_clause = {"TODO"}
//20.12
output_using_clause = {"TODO"}
//20.13
execute_statement = {"TODO"}
//20.14
execute_immediate_statement = {"TODO"}
//20.15
dynamic_declare_cursor = {"TODO"}
//20.16
descriptor_value_constructor = {"TODO"}
//20.17
allocate_extended_dynamic_cursor_statement = {"TODO"}
//20.18
allocate_received_cursor_statement = {"TODO"}
//20.19
dynamic_open_statement = {"TODO"}
//20.20
dynamic_fetch_statement = {"TODO"}
//20.21
dynamic_single_row_select_statement = {"TODO"}
//20.22
dynamic_close_statement = {"TODO"}
//20.23
dynamic_delete_statement_positioned = {"TODO"}
//20.24
dynamic_update_statement_positioned = {"TODO"}
//20.25
preparable_dynamic_delete_statement_positioned = {"TODO"}
//20.26
preparable_dynamic_cursor_name = {"TODO"}
//20.27
preparable_dynamic_update_statement_positioned = {"TODO"}
//20.28
pipe_row_statement = {
    "PIPE" ~ "ROW" ~ ptf_descriptor_name 
}

//21.1
//21.2
//21.3
//21.4
//21.5
//21.6
//21.7
//21.8
//21.9

//22.1 direct sql statement
direct_sql_statement = {
    directly_executable_statement ~ semicolon
}
directly_executable_statement = {
    direct_sql_data_statement 
    | sql_schema_statement 
    | sql_transaction_statement 
    | sql_connection_statement 
    | sql_session_statement  
}
direct_sql_data_statement = {
    delete_statement_searched 
    | direct_select_statement_multiple_rows 
    | insert_statement 
    | update_statement_searched 
    | truncate_table_statement 
    | merge_statement 
    | temporary_table_declaration
} 

//22.2 direct select statement: multiple rows
direct_select_statement_multiple_rows = {
    cursor_specification
} 

//23.1 get diagnostics statement
get_diagnostics_statement = {
    "GET" ~ "DIAGNOSTICS" ~ sql_diagnostics_information
} 
sql_diagnostics_information = {
    statement_information 
    | condition_information 
    | all_information 
}
statement_information = {
    statement_information_item ~ (comma ~ statement_information_item)*
}
statement_information_item = {
    simple_target_specification ~ equals_operator ~ statement_information_item_name
} 
statement_information_item_name = {
    "NUMBER"
    | "MORE"
    | "COMMAND_FUNCTION"
    | "COMMAND_FUNCTION_CODE"
    | "DYNAMIC_FUNCTION"
    | "DYNAMIC_FUNCTION_CODE"
    | "ROW_COUNT"
    | "TRANSACTIONS_COMMITTED"
    | "TRANSACTIONS_ROLLED_BACK"
    | "TRANSACTION_ACTIVE"
}
condition_information = {
    "CONDITION" ~ condition_number ~ condition_information_item 
    ~ (comma ~ condition_information_item)*
}
condition_information_item = {
    simple_target_specification ~ equals_operator ~ condition_information_item_name
} 
condition_information_item_name = {
    "CATALOG_NAME"
    | "CLASS_ORIGIN"
    | "COLUMN_NAME"
    | "CONDITION_NUMBER"
    | "CONNECTION_NAME"
    | "CONSTRAINT_CATALOG"
    | "CONSTRAINT_NAME"
    | "CONSTRAINT_SCHEMA"
    | "CURSOR_NAME"
    | "MESSAGE_LENGTH"
    | "MESSAGE_OCTET_LENGTH"
    | "MESSAGE_TEXT"
    | "PARAMETER_MODE"
    | "PARAMETER_NAME"
    | "PARAMETER_ORDINAL_POSITION"
    | "RETURNED_SQLSTATE"
    | "ROUTINE_CATALOG"
    | "ROUTINE_NAME"
    | "ROUTINE_SCHEMA"
    | "SCHEMA_NAME"
    | "SERVER_NAME"
    | "SPECIFIC_NAME"
    | "SUBCLASS_ORIGIN"
    | "TABLE_NAME"
    | "TRIGGER_CATALOG"
    | "TRIGGER_NAME"
    | "TRIGGER_SCHEMA"
}
all_information = {
    all_info_target ~ equals_operator ~ "ALL" ~ all_qualifier?
}
all_info_target = {
    simple_target_specification
}
all_qualifier = {
    "STATEMENT"
    | "CONDITION" ~ condition_number
}
condition_number = {
    simple_value_specification
} 





